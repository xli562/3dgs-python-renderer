import numpy as np
from scipy.spatial.transform import Rotation
from plyfile import PlyData, PlyElement
from tqdm import tqdm
from dataclasses import dataclass

@dataclass
class GaussianData:
    """ A dataclass to hold multiple 3D Gaussians, 
    using numpy.
    """

    xyz: np.ndarray
    rot: np.ndarray     # rotation of gaus
    scale: np.ndarray   # stretching of gaus
    opacity: np.ndarray     # aka 'alpha' value
    sh: np.ndarray  # Spherical harmonics
    def flat(self) -> np.ndarray:
        ret = np.concatenate([self.xyz, self.rot, self.scale, self.opacity, self.sh], axis=-1)
        return np.ascontiguousarray(ret)

    def __len__(self):
        """ How many Gaussians does the instance contain """
        return len(self.xyz)
    
    def __str__(self):
        """ Returns:
        simple string describing class and length of the instance """
        return f'class GaussianData containing {len(self)} Gaussians.'
    
    def __repr__(self):
        """ Overwrites the __repr__ method generated by the @dataclass decorator
        for clatiry.

        Returns:
            An exhaustive string description of the Gaussians in the dataclass.
        """
        ret_str = f'class GaussianData containing the following {len(self)} Gaussians:\n\n'
        for i in tqdm(range(len(self)), desc='Executing GaussianData.__repr__()',
                      leave=False):
            ret_str += f'Gaussian {i}\n'
            ret_str += f'xyz: {self.xyz[i]}\n'
            ret_str += f'rot: {self.rot[i]}\n'
            ret_str += f'scale: {self.scale[i]}\n'
            ret_str += f'opacity: {self.opacity[i]}\n'
            ret_str += f'sh: {self.sh[i]}\n'
            ret_str += '\n'
        return ret_str

    @property
    def sh_dim(self):
        return self.sh.shape[-1]

SH_C0 = 0.28209479177387814
SH_C1 = 0.4886025119029199
SH_C2_0 = 1.0925484305920792
SH_C2_1 = -1.0925484305920792
SH_C2_2 = 0.31539156525252005
SH_C2_3 = -1.0925484305920792
SH_C2_4 = 0.5462742152960396
SH_C3_0 = -0.5900435899266435
SH_C3_1 = 2.890611442640554
SH_C3_2 = -0.4570457994644658
SH_C3_3 = 0.3731763325901154
SH_C3_4 = -0.4570457994644658
SH_C3_5 = 1.445305721320277
SH_C3_6 = -0.5900435899266435

class Gaussian:
    """ Represents a single 3D Gaussian. Properties: position, 
    scale, rotation, opacity, and spherical harmonics.

    Attributes:
        pos (np.ndarray): Centre of Gaussian in Cartesians
        scale (np.ndarray): Stretching applied along the Gaussian's axes.
        rot (Rotation): A scipy rotation object representing the rotation.
        opacity (float): The opacity level of the Gaussian.
        sh (np.ndarray): Spherical harmonics coefficients.
        cov3D (np.ndarray): The covariance matrix in 3D.
    """

    scale_modifier = 1.0

    def __init__(self, pos, scale, rot, opacity, sh):
        """ Initializes the 3D Gaussian object with provided position, scale, rotation, opacity, and spherical harmonics coefficients.

        Parameters:
            pos (np.ndarray): 3D Cartesian position vector in world coordinates.
            scale (np.ndarray): Scaling factors along each axis.
            rot (np.ndarray): Quaternion rotation coefficients (s, x, y, z).
            opacity (np.ndarray): Opacity value.
            sh (np.ndarray): Spherical harmonics coefficients.
        """
        self.pos = np.array(pos)
        self.scale = np.array(self.scale_modifier * scale)
        # Initialize scipy Quaternion from rot (s, x, y, z)
        self.rot = Rotation.from_quat([rot[1], rot[2], rot[3], rot[0]])
        self.opacity = opacity[0]
        self.sh = np.array(sh)
        self.cov3D = self.compute_cov3d()

    def __str__(self):
        return f'Gaussian centred at {self.pos}'
    
    def __repr__(self):
        ret_str = 'class Gaussian with:\n'
        ret_str += f'pos: {self.pos}\n'
        ret_str += f'scale: {self.scale}\n'
        ret_str += f'rotation: {self.rot.as_rotvec()}\n'    # Magnitude is rot angle, dirn is rot axis
        ret_str += f'opacity: {self.opacity}\n'
        return ret_str

    def compute_cov3d(self):
        """ Computes the covariance matrix in 3D based on 
        the scale and rotation of the Gaussian.

        Returns:
            np.ndarray: The computed covariance matrix.
        """
        cov3D = np.diag(self.scale**2)
        cov3D = self.rot.as_matrix().T @ cov3D @ self.rot.as_matrix()
        return cov3D

    def get_cov2d(self, camera):
        """ Projects the 3D covariance matrix to a 2D covariance 
        matrix using the camera's view matrix.

        Parameters:
            camera (Camera): The camera object to provide view matrix 
            and other camera-specific parameters.

        Returns:
            np.ndarray: The 2D covariance matrix after projection.
        """
        view_mat = camera.get_view_matrix()
        g_pos_w = np.append(self.pos, 1.0)
        # g_pos_cam = camera.world_to_cam(self.pos)
        g_pos_cam = view_mat @ g_pos_w
        view_matrix = camera.get_view_matrix()
        [htan_fovx, htan_fovy, focal] = camera.get_htanfovxy_focal()
        focal_x = focal_y = focal

        t = np.copy(g_pos_cam)

        limx = 1.3 * htan_fovx
        limy = 1.3 * htan_fovy
        txtz = t[0]/t[2]
        tytz = t[1]/t[2]

        tx = min(limx, max(-limx, txtz)) * t[2]
        ty = min(limy, max(-limy, tytz)) * t[2]
        tz = t[2]

        J = np.array([
            [focal_x/tz, 0.0, -(focal_x * tx)/(tz * tz)],
            [0.0, focal_y/tz, -(focal_y * ty)/(tz * tz)],
            [0.0, 0.0, 0.0]
        ])
        W = view_matrix[:3, :3].T
        T = W @ J
        cov = T.T @ self.cov3D.T @ T

        cov[0,0] += 0.3
        cov[1,1] += 0.3
        return cov[:2, :2]

    def get_depth(self, camera):
        """ Calculates the depth of the Gaussian's position 
        relative to the camera.

        Parameters:
            camera (Camera): The camera object to provide the view matrix.

        Returns:
            float: Depth of the Gaussian in camera view space.
        """
        view_matrix = camera.get_view_matrix()
        
        position4 = np.append(self.pos, 1.0)
        g_pos_view = view_matrix @ position4
        depth = g_pos_view[2]
        return depth

    def get_conic_and_bb(self, camera):
        """ Computes the conic representation (i.e. projected ellipse) and 
        bounding box of the Gaussian in camera coords and normalized device coords.

        Parameters:
            camera (Camera): The camera object to provide the view matrix.

        Returns:
            tuple: (Conic representation, bounding box in camera space, 
            bounding box in normalized device coordinates)
        """
        cov2d = self.get_cov2d(camera)

        det = np.linalg.det(cov2d)
        if det == 0.0:
            return None
        
        det_inv = 1.0 / det
        cov = [cov2d[0,0], cov2d[0,1], cov2d[1,1]]
        conic = np.array([cov[2] * det_inv, -cov[1] * det_inv, cov[0] * det_inv])
        # compute 3-sigma bounding box size
        bboxsize_cam = np.array([3.0 * np.sqrt(cov2d[0,0]), 3.0 * np.sqrt(cov2d[1,1])])
        # Divide out camera plane size to get bounding box size in NDC
        wh = np.array([camera.w, camera.h])
        bboxsize_ndc = np.divide(bboxsize_cam, wh) * 2

        vertices = np.array([[-1, 1], [1, 1], [1, -1], [-1, -1]])
        # Four coordxy values (used to evaluate gaussian, also in camera space coordinates)
        bboxsize_cam = np.multiply(vertices, bboxsize_cam)

        # compute g_pos_screen and gl_position
        view_matrix = camera.get_view_matrix()
        projection_matrix = camera.get_projection_matrix()

        position4 = np.append(self.pos, 1.0)
        g_pos_view = view_matrix @ position4
        g_pos_screen = projection_matrix @ g_pos_view
        g_pos_screen = g_pos_screen / g_pos_screen[3]
        
        bbox_ndc = np.multiply(vertices, bboxsize_ndc) + g_pos_screen[:2]
        bbox_ndc = np.hstack((bbox_ndc, np.zeros((vertices.shape[0],2))))
        bbox_ndc[:,2:4] = g_pos_screen[2:4]

        return conic, bboxsize_cam, bbox_ndc

    def get_color(self, dir) -> np.ndarray:
        """ Samples spherical harmonics to get color for given view direction """
        c0 = self.sh[0:3]   # f_dc_* from the ply file)
        color = SH_C0 * c0

        shdim = len(self.sh)

        if shdim > 3:
            # Add the first order spherical harmonics
            c1 = self.sh[3:6]
            c2 = self.sh[6:9]
            c3 = self.sh[9:12]
    
            x = dir[0]
            y = dir[1]
            z = dir[2]
            color = color - SH_C1 * y * c1 + SH_C1 * z * c2 - SH_C1 * x * c3
            
        if shdim > 12:
            c4 = self.sh[12:15]
            c5 = self.sh[15:18]
            c6 = self.sh[18:21]
            c7 = self.sh[21:24]
            c8 = self.sh[24:27]
    
            (xx, yy, zz) = (x * x, y * y, z * z)
            (xy, yz, xz) = (x * y, y * z, x * z)
            
            color = color +	SH_C2_0 * xy * c4 + \
                SH_C2_1 * yz * c5 + \
                SH_C2_2 * (2.0 * zz - xx - yy) * c6 + \
                SH_C2_3 * xz * c7 + \
                SH_C2_4 * (xx - yy) * c8

        if shdim > 27:
            c9 = self.sh[27:30]
            c10 = self.sh[30:33]
            c11 = self.sh[33:36]
            c12 = self.sh[36:39]
            c13 = self.sh[39:42]
            c14 = self.sh[42:45]
            c15 = self.sh[45:48]
    
            color = color + \
                SH_C3_0 * y * (3.0 * xx - yy) * c9 + \
                SH_C3_1 * xy * z * c10 + \
                SH_C3_2 * y * (4.0 * zz - xx - yy) * c11 + \
                SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy) * c12 + \
                SH_C3_4 * x * (4.0 * zz - xx - yy) * c13 + \
                SH_C3_5 * z * (xx - yy) * c14 + \
                SH_C3_6 * x * (xx - 3.0 * yy) * c15
        
        color += 0.5
        return np.clip(color, 0.0, 1.0)


def naive_gaussians():
    """ Generates 4 Gaussians, for use as debugging data """
    gau_xyz = np.array([
        0, 0, 0,
        1, 0, 0,
        0, 1, 0,
        0, 0, 1,
    ]).astype(np.float32).reshape(-1, 3)
    gau_rot = np.array([
        1, 0, 0, 0,
        1, 0, 0, 0,
        1, 0, 0, 0,
        1, 0, 0, 0
    ]).astype(np.float32).reshape(-1, 4)
    gau_s = np.array([
        0.03, 0.03, 0.03,
        0.2, 0.03, 0.03,
        0.03, 0.2, 0.03,
        0.03, 0.03, 0.2
    ]).astype(np.float32).reshape(-1, 3)
    gau_c = np.array([
        1, 0, 1,
        1, 0, 0,
        0, 1, 0,
        0, 0, 1,
    ]).astype(np.float32).reshape(-1, 3)
    gau_c = (gau_c - 0.5) / 0.28209
    gau_a = np.array([
        1, 1, 1, 1
    ]).astype(np.float32).reshape(-1, 1)
    return GaussianData(
        gau_xyz,
        gau_rot,
        gau_s,
        gau_a,
        gau_c
    )


def load_gau_from_ply(path, num_samples:int=-1):
    """ Loads Gaussians from a .ply file. Assumes presence of 
    'x', 'y', 'z', 'rot', 'opacity', 'f_dc_0' to 'f_dc_2', 
    'f_rest_0' to 'f_rest_n', and 'scale_0' to 'scale_n'. 
    Reshapes and normalizes certain features as part of the 
    data preparation process.

    Parameters:
    path (str): The file path to the PLY file to be read.
    num_samples (int) (optional): Number of sampled points.
                Uses uniform sampling. Default is -1.
                Takes all points if max_samples <= 0.

    Returns:
    A GaussianData instance containing all Gaussians from the file.

    Raises:
    AssertionError: If the number of extra feature names does not 
    match the expected count.
    """
    max_sh_degree = 3
    ply_data = PlyData.read(path)

    if num_samples > 0:
        ply_data = ply_data['vertex'].data
        total_points = len(ply_data)
        step = total_points // num_samples
        indices = np.arange(0, total_points, step)
        indices = indices[:num_samples]
        sampled_data = ply_data[indices]
        sampled_element = PlyElement.describe(sampled_data, 'vertex')
        ply_data = PlyData([sampled_element])

    xyz = np.stack((np.asarray(ply_data.elements[0]["x"]),
                    np.asarray(ply_data.elements[0]["y"]),
                    np.asarray(ply_data.elements[0]["z"])),  axis=1)
    opacities = np.asarray(ply_data.elements[0]["opacity"])[..., np.newaxis]

    features_dc = np.zeros((xyz.shape[0], 3, 1))
    features_dc[:, 0, 0] = np.asarray(ply_data.elements[0]["f_dc_0"])
    features_dc[:, 1, 0] = np.asarray(ply_data.elements[0]["f_dc_1"])
    features_dc[:, 2, 0] = np.asarray(ply_data.elements[0]["f_dc_2"])

    extra_f_names = [p.name for p in ply_data.elements[0].properties if p.name.startswith("f_rest_")]
    extra_f_names = sorted(extra_f_names, key = lambda x: int(x.split('_')[-1]))
    assert len(extra_f_names)==3 * (max_sh_degree + 1) ** 2 - 3
    features_extra = np.zeros((xyz.shape[0], len(extra_f_names)))
    for idx, attr_name in enumerate(extra_f_names):
        features_extra[:, idx] = np.asarray(ply_data.elements[0][attr_name])
    # Reshape (P,F*SH_coeffs) to (P, F, SH_coeffs except DC)
    features_extra = features_extra.reshape((features_extra.shape[0], 3, (max_sh_degree + 1) ** 2 - 1))
    features_extra = np.transpose(features_extra, [0, 2, 1])

    scale_names = [p.name for p in ply_data.elements[0].properties if p.name.startswith("scale_")]
    scale_names = sorted(scale_names, key = lambda x: int(x.split('_')[-1]))
    scales = np.zeros((xyz.shape[0], len(scale_names)))
    for idx, attr_name in enumerate(scale_names):
        scales[:, idx] = np.asarray(ply_data.elements[0][attr_name])

    rot_names = [p.name for p in ply_data.elements[0].properties if p.name.startswith("rot")]
    rot_names = sorted(rot_names, key = lambda x: int(x.split('_')[-1]))
    rots = np.zeros((xyz.shape[0], len(rot_names)))
    for idx, attr_name in enumerate(rot_names):
        rots[:, idx] = np.asarray(ply_data.elements[0][attr_name])

    # pass activate function
    xyz = xyz.astype(np.float32)
    rots = rots / np.linalg.norm(rots, axis=-1, keepdims=True)
    rots = rots.astype(np.float32)
    scales = np.exp(scales)
    scales = scales.astype(np.float32)
    opacities = 1/(1 + np.exp(- opacities))  # sigmoid
    opacities = opacities.astype(np.float32)
    shs = np.concatenate([features_dc.reshape(-1, 3),
                        features_extra.reshape(len(features_dc), -1)], axis=-1).astype(np.float32)
    shs = shs.astype(np.float32)
    return GaussianData(xyz, rots, scales, opacities, shs)